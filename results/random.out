--
-- RANDOM
-- Test random() and allies
--
-- Tests in this file may have a small probability of failure,
-- since we are dealing with randomness.  Try to keep the failure
-- risk for any one test case under 1e-9.
--
-- There should be no duplicates in 1000 random() values.
-- (Assuming 52 random bits in the float8 results, we could
-- take as many as 3000 values and still have less than 1e-9 chance
-- of failure, per https://en.wikipedia.org/wiki/Birthday_problem)
SELECT r, count(*)
FROM (SELECT random() r FROM generate_series(1, 1000)) ss
GROUP BY r HAVING count(*) > 1;
 r | count 
---+-------
(0 rows)

-- The range should be [0, 1).  We can expect that at least one out of 2000
-- random values is in the lowest or highest 1% of the range with failure
-- probability less than about 1e-9.
SELECT count(*) FILTER (WHERE r < 0 OR r >= 1) AS out_of_range,
       (count(*) FILTER (WHERE r < 0.01)) > 0 AS has_small,
       (count(*) FILTER (WHERE r > 0.99)) > 0 AS has_large
FROM (SELECT random() r FROM generate_series(1, 2000)) ss;
 out_of_range | has_small | has_large 
--------------+-----------+-----------
            0 | t         | t
(1 row)

-- Check for uniform distribution using the Kolmogorov-Smirnov test.
CREATE FUNCTION ks_test_uniform_random()
RETURNS boolean AS
$$
DECLARE
  n int := 1000;        -- Number of samples
  c float8 := 1.94947;  -- Critical value for 99.9% confidence
  ok boolean;
BEGIN
  ok := (
    WITH samples AS (
      SELECT random() r FROM generate_series(1, n) ORDER BY 1
    ), indexed_samples AS (
      SELECT (row_number() OVER())-1.0 i, r FROM samples
    )
    SELECT max(abs(i/n-r)) < c / sqrt(n) FROM indexed_samples
  );
  RETURN ok;
END
$$
LANGUAGE plpgsql;
-- As written, ks_test_uniform_random() returns true about 99.9%
-- of the time.  To get down to a roughly 1e-9 test failure rate,
-- just run it 3 times and accept if any one of them passes.
SELECT ks_test_uniform_random() OR
       ks_test_uniform_random() OR
       ks_test_uniform_random() AS uniform;
 uniform 
---------
 t
(1 row)

-- now test random_normal()
-- As above, there should be no duplicates in 1000 random_normal() values.
SELECT r, count(*)
FROM (SELECT random_normal() r FROM generate_series(1, 1000)) ss
GROUP BY r HAVING count(*) > 1;
 r | count 
---+-------
(0 rows)

-- ... unless we force the range (standard deviation) to zero.
-- This is a good place to check that the mean input does something, too.
SELECT r, count(*)
FROM (SELECT random_normal(10, 0) r FROM generate_series(1, 100)) ss
GROUP BY r;
 r  | count 
----+-------
 10 |   100
(1 row)

SELECT r, count(*)
FROM (SELECT random_normal(-10, 0) r FROM generate_series(1, 100)) ss
GROUP BY r;
  r  | count 
-----+-------
 -10 |   100
(1 row)

-- Check standard normal distribution using the Kolmogorov-Smirnov test.
CREATE FUNCTION ks_test_normal_random()
RETURNS boolean AS
$$
DECLARE
  n int := 1000;        -- Number of samples
  c float8 := 1.94947;  -- Critical value for 99.9% confidence
  ok boolean;
BEGIN
  ok := (
    WITH samples AS (
      SELECT random_normal() r FROM generate_series(1, n) ORDER BY 1
    ), indexed_samples AS (
      SELECT (row_number() OVER())-1.0 i, r FROM samples
    )
    SELECT max(abs((1+erf(r/sqrt(2)))/2 - i/n)) < c / sqrt(n)
    FROM indexed_samples
  );
  RETURN ok;
END
$$
LANGUAGE plpgsql;
-- As above, ks_test_normal_random() returns true about 99.9%
-- of the time, so try it 3 times and accept if any test passes.
SELECT ks_test_normal_random() OR
       ks_test_normal_random() OR
       ks_test_normal_random() AS standard_normal;
 standard_normal 
-----------------
 t
(1 row)

-- Test random(min, max)
-- invalid range bounds
SELECT random(1, 0);
ERROR:  lower bound must be less than or equal to upper bound
SELECT random(1000000000001, 1000000000000);
ERROR:  lower bound must be less than or equal to upper bound
SELECT random(-2.0, -3.0);
ERROR:  lower bound must be less than or equal to upper bound
SELECT random('NaN'::numeric, 10);
ERROR:  lower bound cannot be NaN
SELECT random('-Inf'::numeric, 0);
ERROR:  lower bound cannot be infinity
SELECT random(0, 'NaN'::numeric);
ERROR:  upper bound cannot be NaN
SELECT random(0, 'Inf'::numeric);
ERROR:  upper bound cannot be infinity
-- empty range is OK
SELECT random(101, 101);
 random 
--------
    101
(1 row)

SELECT random(1000000000001, 1000000000001);
    random     
---------------
 1000000000001
(1 row)

SELECT random(3.14, 3.14);
 random 
--------
   3.14
(1 row)

-- There should be no triple duplicates in 1000 full-range 32-bit random()
-- values.  (Each of the C(1000, 3) choices of triplets from the 1000 values
-- has a probability of 1/(2^32)^2 of being a triple duplicate, so the
-- average number of triple duplicates is 1000 * 999 * 998 / 6 / 2^64, which
-- is roughly 9e-12.)
SELECT r, count(*)
FROM (SELECT random(-2147483648, 2147483647) r
      FROM generate_series(1, 1000)) ss
GROUP BY r HAVING count(*) > 2;
 r | count 
---+-------
(0 rows)

-- There should be no duplicates in 1000 full-range 64-bit random() values.
SELECT r, count(*)
FROM (SELECT random_normal(-9223372036854775808, 9223372036854775807) r
      FROM generate_series(1, 1000)) ss
GROUP BY r HAVING count(*) > 1;
 r | count 
---+-------
(0 rows)

-- There should be no duplicates in 1000 15-digit random() numeric values.
SELECT r, count(*)
FROM (SELECT random_normal(0, 1 - 1e-15) r
      FROM generate_series(1, 1000)) ss
GROUP BY r HAVING count(*) > 1;
 r | count 
---+-------
(0 rows)

-- Expect at least one out of 2000 random values to be in the lowest and
-- highest 1% of the range.
SELECT (count(*) FILTER (WHERE r < -2104533975)) > 0 AS has_small,
       (count(*) FILTER (WHERE r > 2104533974)) > 0 AS has_large
FROM (SELECT random(-2147483648, 2147483647) r FROM generate_series(1, 2000)) ss;
 has_small | has_large 
-----------+-----------
 t         | t
(1 row)

SELECT count(*) FILTER (WHERE r < -1500000000 OR r > 1500000000) AS out_of_range,
       (count(*) FILTER (WHERE r < -1470000000)) > 0 AS has_small,
       (count(*) FILTER (WHERE r > 1470000000)) > 0 AS has_large
FROM (SELECT random(-1500000000, 1500000000) r FROM generate_series(1, 2000)) ss;
 out_of_range | has_small | has_large 
--------------+-----------+-----------
            0 | t         | t
(1 row)

SELECT (count(*) FILTER (WHERE r < -9038904596117680292)) > 0 AS has_small,
       (count(*) FILTER (WHERE r > 9038904596117680291)) > 0 AS has_large
FROM (SELECT random(-9223372036854775808, 9223372036854775807) r
      FROM generate_series(1, 2000)) ss;
 has_small | has_large 
-----------+-----------
 t         | t
(1 row)

SELECT count(*) FILTER (WHERE r < -1500000000000000 OR r > 1500000000000000) AS out_of_range,
       (count(*) FILTER (WHERE r < -1470000000000000)) > 0 AS has_small,
       (count(*) FILTER (WHERE r > 1470000000000000)) > 0 AS has_large
FROM (SELECT random(-1500000000000000, 1500000000000000) r
      FROM generate_series(1, 2000)) ss;
 out_of_range | has_small | has_large 
--------------+-----------+-----------
            0 | t         | t
(1 row)

SELECT count(*) FILTER (WHERE r < -1.5 OR r > 1.5) AS out_of_range,
       (count(*) FILTER (WHERE r < -1.47)) > 0 AS has_small,
       (count(*) FILTER (WHERE r > 1.47)) > 0 AS has_large
FROM (SELECT random(-1.500000000000000, 1.500000000000000) r
      FROM generate_series(1, 2000)) ss;
 out_of_range | has_small | has_large 
--------------+-----------+-----------
            0 | t         | t
(1 row)

-- Every possible value should occur at least once in 2500 random() values
-- chosen from a range with 100 distinct values.
SELECT min(r), max(r), count(r) FROM (
  SELECT DISTINCT random(-50, 49) r FROM generate_series(1, 2500));
 min | max | count 
-----+-----+-------
 -50 |  49 |   100
(1 row)

SELECT min(r), max(r), count(r) FROM (
  SELECT DISTINCT random(123000000000, 123000000099) r
  FROM generate_series(1, 2500));
     min      |     max      | count 
--------------+--------------+-------
 123000000000 | 123000000099 |   100
(1 row)

SELECT min(r), max(r), count(r) FROM (
  SELECT DISTINCT random(-0.5, 0.49) r FROM generate_series(1, 2500));
  min  | max  | count 
-------+------+-------
 -0.50 | 0.49 |   100
(1 row)

-- Check for uniform distribution using the Kolmogorov-Smirnov test.
CREATE FUNCTION ks_test_uniform_random_int_in_range()
RETURNS boolean AS
$$
DECLARE
  n int := 1000;        -- Number of samples
  c float8 := 1.94947;  -- Critical value for 99.9% confidence
  ok boolean;
BEGIN
  ok := (
    WITH samples AS (
      SELECT random(0, 999999) / 1000000.0 r FROM generate_series(1, n) ORDER BY 1
    ), indexed_samples AS (
      SELECT (row_number() OVER())-1.0 i, r FROM samples
    )
    SELECT max(abs(i/n-r)) < c / sqrt(n) FROM indexed_samples
  );
  RETURN ok;
END
$$
LANGUAGE plpgsql;
SELECT ks_test_uniform_random_int_in_range() OR
       ks_test_uniform_random_int_in_range() OR
       ks_test_uniform_random_int_in_range() AS uniform_int;
 uniform_int 
-------------
 t
(1 row)

CREATE FUNCTION ks_test_uniform_random_bigint_in_range()
RETURNS boolean AS
$$
DECLARE
  n int := 1000;        -- Number of samples
  c float8 := 1.94947;  -- Critical value for 99.9% confidence
  ok boolean;
BEGIN
  ok := (
    WITH samples AS (
      SELECT random(0, 999999999999) / 1000000000000.0 r FROM generate_series(1, n) ORDER BY 1
    ), indexed_samples AS (
      SELECT (row_number() OVER())-1.0 i, r FROM samples
    )
    SELECT max(abs(i/n-r)) < c / sqrt(n) FROM indexed_samples
  );
  RETURN ok;
END
$$
LANGUAGE plpgsql;
SELECT ks_test_uniform_random_bigint_in_range() OR
       ks_test_uniform_random_bigint_in_range() OR
       ks_test_uniform_random_bigint_in_range() AS uniform_bigint;
 uniform_bigint 
----------------
 t
(1 row)

CREATE FUNCTION ks_test_uniform_random_numeric_in_range()
RETURNS boolean AS
$$
DECLARE
  n int := 1000;        -- Number of samples
  c float8 := 1.94947;  -- Critical value for 99.9% confidence
  ok boolean;
BEGIN
  ok := (
    WITH samples AS (
      SELECT random(0, 0.999999) r FROM generate_series(1, n) ORDER BY 1
    ), indexed_samples AS (
      SELECT (row_number() OVER())-1.0 i, r FROM samples
    )
    SELECT max(abs(i/n-r)) < c / sqrt(n) FROM indexed_samples
  );
  RETURN ok;
END
$$
LANGUAGE plpgsql;
SELECT ks_test_uniform_random_numeric_in_range() OR
       ks_test_uniform_random_numeric_in_range() OR
       ks_test_uniform_random_numeric_in_range() AS uniform_numeric;
 uniform_numeric 
-----------------
 t
(1 row)

-- setseed() should produce a reproducible series of random() values.
SELECT setseed(0.5);
 setseed 
---------
 
(1 row)

SELECT random() FROM generate_series(1, 10);
       random        
---------------------
  0.9851677175347999
   0.825301858027981
 0.12974610012450416
 0.16356291958601088
     0.6476186144084
  0.8822771983038762
  0.1404566845227775
 0.15619865764623442
  0.5145227426983392
  0.7712969548127826
(10 rows)

-- Likewise for random_normal(); however, since its implementation relies
-- on libm functions that have different roundoff behaviors on different
-- machines, we have to round off the results a bit to get consistent output.
SET extra_float_digits = -1;
SELECT random_normal() FROM generate_series(1, 10);
   random_normal   
-------------------
  0.20853464493838
  0.26453024054096
 -0.60675246790043
  0.82579942785265
   1.7011161173536
 -0.22344546371619
    0.249712419191
  -1.2494722990669
  0.12562715204368
  0.47539161454401
(10 rows)

SELECT random_normal(mean => 1, stddev => 0.1) r FROM generate_series(1, 10);
        r         
------------------
  1.0060597281173
    1.09685453015
  1.0286920613201
 0.90947567671234
 0.98372476313426
 0.93934454957762
  1.1871350020636
 0.96225768429293
 0.91444120680041
 0.96403105557543
(10 rows)

-- Reproducible random(min, max) values.
SELECT random(1, 6) FROM generate_series(1, 10);
 random 
--------
      5
      4
      5
      1
      6
      1
      1
      3
      6
      5
(10 rows)

SELECT random(-2147483648, 2147483647) FROM generate_series(1, 10);
   random    
-------------
   -84380014
  1287883594
 -1927252904
    13516867
 -1902961616
 -1824286201
  -871264469
 -1225880415
   229836730
  -116039023
(10 rows)

SELECT random(-9223372036854775808, 9223372036854775807) FROM generate_series(1, 10);
        random        
----------------------
 -6205280962992680052
 -3583519428011353337
   511801786318122700
  4672737727839409655
 -6674868801536280768
 -7816052100626646489
 -4340613370136007199
 -5873174504107419786
 -2249910101649817824
 -4493828993910792325
(10 rows)

SELECT random(-1e30, 1e30) FROM generate_series(1, 10);
             random              
---------------------------------
 -732116469803311122594293145554
  794641423514877984797298574928
 -576932746026123046309347183834
  420625067723531397322547576185
 -339227806779408110318789180108
  -77667951539419592810426354174
  239810941795706293816215992807
  820784371155890521696766974194
 -377084684544121504687183513905
 -979773225250710072629567252509
(10 rows)

SELECT random(-0.4, 0.4) FROM generate_series(1, 10);
 random 
--------
    0.1
    0.0
    0.4
   -0.2
    0.1
    0.2
    0.3
    0.0
   -0.2
    0.2
(10 rows)

SELECT random(0, 1 - 1e-30) FROM generate_series(1, 10);
              random              
----------------------------------
 0.676442053784930108125462478051
 0.315825065487367368320788128819
 0.259087482585009293679245707439
 0.651998311172963212498299034983
 0.654835281047779842548781612023
 0.349371796291289137995007966596
 0.431480342655738424598705110287
 0.905224364729837918528164599634
 0.434596460023939099830141190076
 0.353262552880008638180235931654
(10 rows)

SELECT n, random(0, trim_scale(abs(1 - 10.0^(-n)))) FROM generate_series(-20, 20) n;
  n  |         random         
-----+------------------------
 -20 |   82850595871428623123
 -19 |    5611469268101166268
 -18 |     725452995708066694
 -17 |      19952125319148332
 -16 |       2729709319727111
 -15 |        655667906446821
 -14 |         43358410571101
 -13 |          8960324830292
 -12 |           637151835788
 -11 |            65643755719
 -10 |             1431943289
  -9 |              721762876
  -8 |               24653299
  -7 |                9757510
  -6 |                  22214
  -5 |                  59658
  -4 |                   4232
  -3 |                    378
  -2 |                     47
  -1 |                      8
   0 |                      0
   1 |                    0.8
   2 |                   0.07
   3 |                  0.628
   4 |                 0.8565
   5 |                0.19566
   6 |               0.623293
   7 |              0.7059872
   8 |             0.76400237
   9 |            0.388737802
  10 |           0.4305806734
  11 |          0.83648046618
  12 |         0.791414497615
  13 |        0.2886825485725
  14 |       0.97916534835565
  15 |      0.652274425931523
  16 |     0.2962046095872221
  17 |    0.44138103626349051
  18 |   0.962422665407042238
  19 |  0.6540572724801382012
  20 | 0.88838482726422796873
(41 rows)

-- random dates
SELECT random('1979-02-08'::date,'2025-07-03'::date) AS random_date_multiple_years;
 random_date_multiple_years 
----------------------------
 06-17-2000
(1 row)

SELECT random('4714-11-24 BC'::date,'5874897-12-31 AD'::date) AS random_date_maximum_range;
 random_date_maximum_range 
---------------------------
 02-24-1331061
(1 row)

SELECT random('1979-02-08'::date,'1979-02-08'::date) AS random_date_empty_range;
 random_date_empty_range 
-------------------------
 02-08-1979
(1 row)

SELECT random('2024-12-31'::date, '2024-01-01'::date); -- fail
ERROR:  lower bound must be less than or equal to upper bound
SELECT random('-infinity'::date, '2024-01-01'::date); -- fail
ERROR:  lower and upper bounds must be finite
SELECT random('2024-12-31'::date, 'infinity'::date); -- fail
ERROR:  lower and upper bounds must be finite
-- random timestamps
SELECT random('1979-02-08'::timestamp,'2025-07-03'::timestamp) AS random_timestamp_multiple_years;
 random_timestamp_multiple_years 
---------------------------------
 Mon Sep 05 14:38:56.009661 1983
(1 row)

SELECT random('4714-11-24 BC'::timestamp,'294276-12-31 23:59:59.999999'::timestamp) AS random_timestamp_maximum_range;
  random_timestamp_maximum_range   
-----------------------------------
 Tue Aug 24 23:22:51.072866 276376
(1 row)

SELECT random('2024-07-01 12:00:00.000001'::timestamp, '2024-07-01 12:00:00.999999'::timestamp) AS random_narrow_range;
       random_narrow_range       
---------------------------------
 Mon Jul 01 12:00:00.472356 2024
(1 row)

SELECT random('1979-02-08'::timestamp,'1979-02-08'::timestamp) AS random_timestamp_empty_range;
 random_timestamp_empty_range 
------------------------------
 Thu Feb 08 00:00:00 1979
(1 row)

SELECT random('2024-12-31'::timestamp, '2024-01-01'::timestamp); -- fail
ERROR:  lower bound must be less than or equal to upper bound
SELECT random('-infinity'::timestamp, '2024-01-01'::timestamp); -- fail
ERROR:  lower and upper bounds must be finite
SELECT random('2024-12-31'::timestamp, 'infinity'::timestamp); -- fail
ERROR:  lower and upper bounds must be finite
-- random timestamps with timezone
SELECT random('1979-02-08 +01'::timestamptz,'2025-07-03 +02'::timestamptz) AS random_timestamptz_multiple_years;
  random_timestamptz_multiple_years  
-------------------------------------
 Sat Jan 23 22:45:55.247165 2021 PST
(1 row)

SELECT random('4714-11-24 BC +00'::timestamptz,'294276-12-31 23:59:59.999999 +00'::timestamptz) AS random_timestamptz_maximum_range;
  random_timestamptz_maximum_range   
-------------------------------------
 Mon Nov 21 18:35:47.90577 58310 PST
(1 row)

SELECT random('2024-07-01 12:00:00.000001 +04'::timestamptz, '2024-07-01 12:00:00.999999 +04'::timestamptz) AS random_timestamptz_narrow_range;
   random_timestamptz_narrow_range   
-------------------------------------
 Mon Jul 01 01:00:00.116477 2024 PDT
(1 row)

SELECT random('1979-02-08 +05'::timestamptz,'1979-02-08 +05'::timestamptz) AS random_timestamptz_empty_range;
 random_timestamptz_empty_range 
--------------------------------
 Wed Feb 07 11:00:00 1979 PST
(1 row)

SELECT random('2024-01-01 +06'::timestamptz, '2024-01-01 +07'::timestamptz); -- fail
ERROR:  lower bound must be less than or equal to upper bound
SELECT random('-infinity'::timestamptz, '2024-01-01 +07'::timestamptz); -- fail
ERROR:  lower and upper bounds must be finite
SELECT random('2024-01-01 +06'::timestamptz, 'infinity'::timestamptz); -- fail
ERROR:  lower and upper bounds must be finite
